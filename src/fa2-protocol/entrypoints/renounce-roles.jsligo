const renounce_roles = (params: renounce_roles_params, permit_opt: option<permit>, s1: storage): @return => {
  let s = s1;

  const sender : address = match(permit_opt, {
    Some: permit => {
      const param_bytes : bytes = Bytes.pack(["%renounce_roles", params]);
      s = check_and_store_permit(permit, param_bytes, s);
      return address_from_key(permit.signer);
    },
    None: () => Tezos.get_sender()
  });

  for (const entry of params) {
    const [kt1, renounce_role_params] = entry;
    const permissions: permissions = get_permissions_or_fail(kt1, s);
    s.roles = Big_map.update(kt1, Some(match(renounce_role_params, {
      Ownership: () => {
        assert_with_error(is_owner([kt1, sender], s), "FA2_INVALID_OWNER_ACCESS");
        return { ...permissions, owner: c_NULL_ADDRESS }
      },
      Creator: () => {
        assert_with_error(has_role([kt1, sender, Creator()], s), "FA2_INVALID_CREATOR_ACCESS");
        return {
          ...permissions,
          creator: Set.remove(sender, permissions.creator)
        }
      },
      Minter: () => {
        assert_with_error(has_role([kt1, sender, Minter()], s), "FA2_INVALID_MINTER_ACCESS");
        return {
          ...permissions,
          minter: Set.remove(sender, permissions.minter)
        }
      },
      Metadata_manager: () => {
        assert_with_error(has_role([kt1, sender, Metadata_manager()], s), "FA2_INVALID_METADATA_MANAGER_ACCESS");
        return {
          ...permissions,
          metadata_manager: Set.remove(sender, permissions.metadata_manager)
        }
      },
      Royalties_manager: () => {
        assert_with_error(has_role([kt1, sender, Royalties_manager()], s), "FA2_INVALID_ROYALTIES_MANAGER_ACCESS");
        return {
          ...permissions,
          royalties_manager: Set.remove(sender, permissions.royalties_manager)
        }
      }
    })), s.roles);
  };

  return [list([]), s]
};
