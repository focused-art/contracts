const update_operators = (params: update_operator_params, permit_opt: option<permit>, s1: storage): @return => {
  let s = s1;

  const sender : address = match(permit_opt, {
    Some: permit => {
      const param_bytes : bytes = Bytes.pack(["%update_operators", params]);
      s = check_and_store_permit(permit, param_bytes, s);
      return address_from_key(permit.signer);
    },
    None: () => Tezos.get_sender()
  });

  // Initialize operations
  let operations: list<operation> = list([]);

  for (const update_operator_param of params) {
    const _ = match(update_operator_param, {
      Add_operator: param => {
        validate_token_id(param.token_id, s);
        assert_with_error(param.owner == sender, "FA2_NOT_OWNER");
        s.operators = Big_map.update(
          [param.owner, [param.operator, param.token_id]],
          Some(unit),
          s.operators
        );

        const operator_update_event: operator_update_event = {
          owner: param.owner,
          operator: param.operator,
          token_id: param.token_id,
          is_operator: true
        };

        operations = list([
          Tezos.emit("%operator_update", operator_update_event),
          ...operations
        ]);
      },
      Remove_operator: param => {
        validate_token_id(param.token_id, s);
        assert_with_error(param.owner == sender, "FA2_NOT_OWNER");
        s.operators = Big_map.remove(
          [param.owner, [param.operator, param.token_id]],
          s.operators
        );

        const operator_update_event: operator_update_event = {
          owner: param.owner,
          operator: param.operator,
          token_id: param.token_id,
          is_operator: false
        };

        operations = list([
          Tezos.emit("%operator_update", operator_update_event),
          ...operations
        ]);
      }
    });
  };

  return [operations, s]
};
